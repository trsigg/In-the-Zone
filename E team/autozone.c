#pragma config(Sensor, in1,    chainPot,       sensorPotentiometer)
#pragma config(Sensor, in2,    liftPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEnc,        sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEnc,       sensorQuadEncoder)
#pragma config(Motor,  port1,           RDrive1,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           RDrive2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           chain1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           intake,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           liftMotors,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LDrive1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           chain2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           goal1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          goal2,         tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#region config
#define TESTING 0	//0 for normal behavior, 1 for PID testing
//#endregion

//#region positions
enum chainState  { CH_DEF,	INTAKE, SAFE, STACK, CH_MIN, VERT, CH_MAX };	//when chain bar is SAFE, lift can move up and down without colliding with cone stack
int chainPos[] = { 1100,    800,    2030, 2800,  600,    2680, 4050 };

enum liftState  { L_DEF, L_ZERO, L_MAX, PRELOAD, M_BASE_POS, S_BASE_POS };
int liftPos[] = { 500,   890,    1660,  525,     400,        900 };
//#endregion

//#region setup
#pragma platform(VEX2)
#pragma competitionControl(Competition)
#include "Vex_Competition_Includes.c"
#include "..\lib\pd_autoMove.c"
#include "..\lib\buttonTracker.c"
//#endregion

//#region buttons
#define stackBtn					Btn5U
	//#subregion lift mode
#define manualModeBtn			Btn7R
#define autostackBtn			Btn7L
	//#endsubregion
	//#subregion
#define goalIntakeBtn			Btn7D
#define goalOuttakeBtn		Btn7U
	//#endsubregion
	//#subregion lift
#define liftUpBtn					Btn5U
#define liftDownBtn				Btn5D
	//#endsubregion
	//#subregion chain bar
#define chainInBtn				Btn6U
#define chainOutBtn				Btn6D
	//#endsubregion
	//#subregion cone intake
#define intakeBtn					Btn8U
#define outtakeBtn				Btn8D
	//#endsubregion
	//#subregion cone count adjustment
#define resetBtn					Btn8L
#define decreaseConesBtn	Btn8D
#define increaseConesBtn	Btn8U
	//#endsubregion
//#endregion

//#region constants
	//#subregion measurements
#define CONE_HEIGHT 2.3
#define LIFT_LEN 13.5
	//#endsubregion
	//#subregion still speeds
#define INTAKE_STILL_SPEED	10
#define LIFT_STILL_SPEED		10
#define CHAIN_STILL_SPEED		10
#define GOAL_STILL_SPEED		15
	//#endsubregion
#define APATHY_CONES 0
#define MAX_NUM_CONES 15
#define INTAKE_DURATION 300	//amount of time rollers activate when intaking/expelling cones
#define OUTTAKE_DURATION 200
#define RAD_TO_POT_FCTR 880.1
#define LIFT_OFFSET 2.0
//#endregion

//#region globals
int numCones = 0; //current number of stacked cones
bool stacking = false;	//whether the robot is currently in the process of stacking
static float heightOffset = sin((liftPos[M_BASE_POS] - liftPos[L_ZERO]) / RAD_TO_POT_FCTR);
float liftAngle1, liftAngle2, chainAngle;	//the target angles of lift sections during a stack maneuver

motorGroup lift;
motorGroup chainBar;
motorGroup goalIntake;
motorGroup coneIntake;
//#endregion

void pre_auton() {
	bStopTasksBetweenModes = true;

	initializeAutoMovement();

	//configure drive
	initializeDrive(drive, true);
	setDriveMotors(drive, 4, LDrive1, LDrive1, RDrive1, RDrive2);
	/*attachEncoder(drive, leftEnc, LEFT);
	attachEncoder(drive, rightEnc, RIGHT, false, 3.25);
	attachGyro(drive, hyro);*/

	//configure lift
	initializeGroup(lift, 1, liftMotors);
	configureButtonInput(lift, liftUpBtn, liftDownBtn);
	configureBtnDependentStillSpeed(lift, LIFT_STILL_SPEED);
  setTargetingPIDconsts(lift, 0.27, 0.003, 2.5, 25);	//.1, .001, .05
	addSensor(lift, liftPot);

	//configure chain bar
	initializeGroup(chainBar, 2, chain1, chain2);	//TODO: setAbsolutes
	setAbsolutes(chainBar, chainPos[CH_MIN], chainPos[CH_MAX]);
	configureButtonInput(chainBar, chainInBtn, chainOutBtn);
	configurePosDependentStillSpeed(chainBar, CHAIN_STILL_SPEED, chainPos[VERT]);
	setTargetingPIDconsts(chainBar, 0.3, 0.001, 0.7, 25);	//0.2, 0.001, 0.15
	addSensor(chainBar, chainPot);

	//configure mobile goal intake
	initializeGroup(goalIntake, 2, goal1, goal2);
	configureButtonInput(goalIntake, goalOuttakeBtn, goalIntakeBtn, GOAL_STILL_SPEED);

	//configure cone intake
	initializeGroup(coneIntake, 1, intake);
	configureButtonInput(coneIntake, intakeBtn, outtakeBtn, INTAKE_STILL_SPEED);
}

//#region lift
void setLiftState(liftState state) {
	setTargetPosition(lift, liftPos[state]);
}
//#endregion

//#region chain bar
void setChainBarState(chainState state) {
	setTargetPosition(chainBar, chainPos[state]);
}
//#endregion

//#region autostacking
void waitForMovementToFinish(bool waitForLift=true, bool waitForChain=true, int timeout=75, float chainMargin=250, float liftMargin=150) {
	long movementTimer = resetTimer();

	while (time(movementTimer) < timeout) {
		if (!errorLessThan(chainBar, chainMargin) && waitForChain ||
				!errorLessThan(lift, liftMargin) && waitForLift)
			movementTimer = resetTimer();
		EndTimeSlice();
	}
}

int adjustedNumCones() {
	return limit(numCones-APATHY_CONES, 0, MAX_NUM_CONES-APATHY_CONES);
}

float calcLiftTargetForHeight(float height) {
	return limit(RAD_TO_POT_FCTR * asin(height / 2 / LIFT_LEN + heightOffset) + liftPos[L_ZERO],
	             liftPos[L_DEF], liftPos[L_MAX]);
}

void stackNewCone() {	//TODO: account for limited range of motion, modulus
	float stackHeight = CONE_HEIGHT * adjustedNumCones();

	chainAngle = chainPos[STACK];
	liftAngle1 = calcLiftTargetForHeight(stackHeight + LIFT_OFFSET);
	liftAngle2 = calcLiftTargetForHeight(stackHeight);
	stacking = true;
}

void executeLiftManeuvers() {
	maintainTargetPos(chainBar);
	maintainTargetPos(lift);
}

void stopLiftTargeting() {
	stopTargeting(chainBar);
	stopTargeting(lift);
}

task autoStacking() {
	while (true) {
		while (!stacking) EndTimeSlice();

		//intake cone
		setChainBarState(INTAKE);
		setLiftState(L_DEF);
		setPower(coneIntake, 127);
		waitForMovementToFinish(true, true, INTAKE_DURATION);
		setPower(coneIntake, INTAKE_STILL_SPEED);

		//move to desired location
		setChainBarState(SAFE);
		setTargetPosition(lift, liftAngle1);

		while (getPosition(lift) < liftAngle2) EndTimeSlice();
		setTargetPosition(chainBar, chainAngle);
		waitForMovementToFinish(false);
		setTargetPosition(lift, liftAngle2, false);	//change target without resetting integral

		waitForMovementToFinish();


		//expel cone
		setPower(coneIntake, -127);
		setTargetPosition(lift, liftAngle1, false);
		waitForMovementToFinish(true, false, OUTTAKE_DURATION);
		setChainBarState(CH_DEF);
		setPower(coneIntake, 0);

		//return to ready positions
		numCones++;
		stacking = false;
		setLiftState(L_DEF);
	}
}

void adjustConeCount() {	//change cone count based on user input
	if (newlyPressed(resetBtn))
			numCones = 0;

	if (newlyPressed(increaseConesBtn))
			numCones++;

	if (newlyPressed(decreaseConesBtn))
			if (numCones > 0)
				numCones--;
}
//#endregion

//#region testing
int targets[] = { 0, 0 };	//chain bar, lift
bool abort = false;
bool end = false;

void testPIDs() {
	int prevTargets[] = { 0, 0 };

	while (!end) {
		if (targets[0] != prevTargets[0]) {
			setTargetPosition(chainBar, targets[0]);
			prevTargets[0] = targets[0];
		}

		if (targets[1] != prevTargets[1]) {
			setTargetPosition(lift, targets[1]);
			prevTargets[1] = targets[1];
		}

		if (abort) {
			stopLiftTargeting();
			setPower(lift, 0);
			setPower(chainBar, 0);
			wait1Msec(50);
			abort = false;
		}

		executeLiftManeuvers();
	}
}

void handleTesting() {
	if (TESTING == 1)
		testPIDs();
}
//#endregion

//#region autonomous
task autonomous() {

}
//#endregion

task usercontrol() {
	handleTesting();

	bool manualLift = true;	//whether lifting is manual or controlled by autostacking

	startTask(autoStacking);

	while (true) {
		if (manualLift) {
			takeInput(lift);
			takeInput(chainBar);
			takeInput(coneIntake);

			if (vexRT[autostackBtn] == 1)
				manualLift = false;
		}
		else {
			if (!stacking && vexRT[stackBtn]==1)
				stackNewCone();

			adjustConeCount();
			executeLiftManeuvers();

			if (vexRT[manualModeBtn] == 1)
				manualLift = true;
		}

		takeInput(goalIntake);
		driveRuntime(drive);
	}
}
